
                                        各种常见布局
块状元素
一.垂直布局
1.上半部分固定高度，下半部分自适应
    1).flex
        DOM文档:
            <main>
                <header>头部</header>
                <div class="main">主体部分</div>
            </body>
        CSS清单:
            body{
                display:flex;
                flex-flow:column;
                min-height:100vh;
            }
            .main{
                flex:1;
            }
        好处：不需要设置高度，头部跟随内容变化高度，主体部分自适应
    2).绝对定位
            .header{
                height: 49px;
            }
            .main{
                position: absolute;
                top: 49px;
                left: 0;
                right: 0;
            }
    3)calc
二.水平布局
1.左右部分定宽，中间部分自适应
    1).float+margin
        DOM文档:
            <div id="content">
                <div class="sub">sub</div>
                <div class="extra">extra</div>
                <div class="main">main</div>
            </div>
        CSS清单:
            .sub{
                width: 100px;
                float: left;
            }
            .extra{
                width: 200px;
                float: right;
            }
            .main{
                margin-left: 100px; 
                margin-right: 200px;
            }
        备注：
            *注意DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。　
            *这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。

    2).position+margin
        DOM文档:
            <div class="sub">left</div>
            <div class="main">main</div>
            <div class="extra">right</div>
        CSS清单:
            .sub, .extra {
                position: absolute;
                top: 0; 
                width: 200px;
            }
            .sub { 
                left: 0;
            }
            .extra { 
                right: 0; 
            }
            .main { 
                margin: 0 200px;
            }
        备注：
            *本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。
            *与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。
            *如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。
    3).圣杯布局(float + 负margin)
        DOM文档:
            <div id="bd">         
                <div class="main"></div>        
                <div class="sub"></div>        
                <div class="extra"></div>  
            </div>
        CSS清单:
            .main {        
                float: left;       
                width: 100%;   
            }  
            .sub {       
                float: left;        
                width: 190px;        
                margin-left: -100%;               
                position: relative;  
                left: -190px;  
            }   
            .extra {        
                float: left;        
                width: 230px;        
                margin-left: -230px; 
                position: relative; 
                right: -230px;  
            }
            #bd {        
                padding: 0 230px 0 190px;   
            }
        备注：
            *DOM元素的书写顺序不得更改。
            *主面板部分优先渲染（一般主面板会比侧栏内容重要）。
            *当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。
    4)双飞翼布局(float + 负margin )
        DOM文档:
            <div class="main-wrap">
                <div class="main">#main</div>
            </div>
            <div class="sub"></div>        
            <div class="extra"></div>
        CSS清单:
            .main-wrap {        
                float: left;       
                width: 100%;   
            }  
            .sub {       
                float: left;        
                width: 190px;        
                margin-left: -100%;   
            }   
            .extra {        
                float: left;        
                width: 230px;        
                margin-left: -230px; 
            }
            .main {    
                margin: 0 230px 0 190px;
            }
        备注：
            *主面板部分优先渲染（一般主面板会比侧栏内容重要）。
            *圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。
            *双飞翼布局不用设置相对布局，以及对应的left和right值。
            *通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px;,可以实现sub+extra+main的布局。

            
https://www.zhihu.com/search?type=content&q=css%E5%B8%83%E5%B1%80


行内元素
1.背景宽度固定，使背景高度跟随元素内容变化（连续的字母被视为一个单词，宽度溢出父元素也不换行）
    .container{
        display:flex;
        background:#ddd;
        width:50vw;
        /* 垂直居中 */
        align-items: center;
        padding:20px 20px;
    }
    .text{
        display: block;
        /* 文本水平居中并换行 flex无法让其中文字换行 所以加一个中间层text*/
        text-align: center;
        overflow-wrap: break-word;
        width:50vw;/* 固定宽度高度随文本内容变化 不能用rem 文字超出后无效 */
    }
2.背景高度固定，使背景宽度跟随元素内容变化
    .container{
        width:-webkit-fit-content（min-content）
    }

    span元素本身就是如此效果

                                                    居中
* 水平居中

    行内元素：text-align
    块状元素: 
        定宽   
                1.margin:auto
                2.
                <div class="parent">
                    <div class="child">使用绝对定位来进行居中</div>
                </div>
                .parent{
                    position:relative;
                }
                .child{
                    width:100px;
                    position:absolute;
                    left:50%;
                    margin-left:-50px;/*该元素宽度的一半*/
                }
        不定宽  1.放在table里或者设置display:inline-block，再设置text-align:center
                2.
                <div class="wrapper">
                    <div class="child">
                        使用浮动配合相对定位实现水平居中
                    </div>
                </div>

                .wrapper{
                    float:left;/*使之自适应内容宽度*/
                    position:relative;
                    left:50%;/*相对本身向右偏移父元素宽度的一半*/
                    clear:both;
                }
                .child{
                    position:relative;
                    left:-50%;/*相对本身向左偏移wrapper（等于本身宽度）一半的宽度*/
                }

* 垂直居中

    行内元素
        1.父元素高度确定的单行文本：line-height和height一样；
        2.父元素确定的多行文本：使用display： table -cell (包括tbody、tr、td)标签，同时设置 vertical-align：middle

    块状元素
        定宽
            <div class="parent">
                <div class="child">使用绝对定位来进行居中</div>
            </div>
            .parent{
                position:relative;
            }
            .child{
                width:100px;
                position:absolute;
                top:50%;
                margin-top:-50px;/*该元素高度的一半*/
            }
        不定宽
            <div class="wrapper">
                <div class="child">
                    使用浮动配合相对定位实现水平居中
                </div>
            </div>

            .wrapper{
                float:left;/*使之自适应内容高度*/
                position:relative;
                top:50%;/*相对本身向右偏移父元素高度的一半*/
                clear:both;
            }
            .child{
                position:relative;
                top:-50%;/*相对本身向左偏移wrapper（等于本身宽度）一半的高度*/
            }
* 完全居中
    .box{
            display: flex;
            justify-content:center;
            align-items:center;
    }

    .box{
            display: flex;
        }
    .box div{margin: auto;}



https://www.cnblogs.com/2050/p/3392803.html 


                                                    经验总结
1.水平垂直格式化
    块状元素：
            水平
                1.最好是特殊布局（居中，平分，左右（justify-content:space-between or flex:1））
                2.最外层：左右留白中间自适应的布局：通过设置margin（padding）：0 10px
            垂直
                1.通常是特殊布局，比如header固定高度，主体自适应
    文字包含块：
        水平
            1.使其宽度随内容变化
        垂直：
            1.包含块高度随内容变化，高度应该由内容确定
    
    几种布局情况：
        1.不用设置高度宽度和边距，flex的几种特殊布局
        2.不用设置高度宽度但要设置边距

2.关于padding和margin的选择    
    在层级少的基础上;    
    是否需要延伸到背景决定选择;   
    在水平格式化时margin可以是auto;   
    外边距是否需要合并(除了浮动元素外边距不会合并其他外边距会合并，内边距不会);   
    其余情况任选。

3.适配：
    用@media+rem(vm、vh可以实现适配但兼容性不好)